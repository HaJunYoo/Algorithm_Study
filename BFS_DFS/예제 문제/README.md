## DFS

스택이나 재귀를 활용

재귀를 활용 자체가 스택을 활용하는 것

DFS 는 완전탐색이기 때문에 모든 노드를 깊이 우선적으로 살펴본다

0→ 1 → 2→ 3 → 4 → 5 → 6→ 7 →  8 → 9 → 10 → 11 → 12

최대한 계속 깊게 파고 내려간 후 올라온다 

해당 방법을 재귀적으로 반복한다

```python
### 인접 행렬로 implementation

# 13 * 13 크기의 행렬 생성
adj = [[0] * 13 for _ in range(13)]

# 간선 별 1 연결 부여 
adj[0][1] = adj[0][7] = 1
adj[1][2] = adj[1][5] = 1

for row in adj : 
	print(row)

# 현재 방문한 노드 now를 인자로 받음
def dfs(now):
	for nxt in range(13):
		# 다음으로 가는 노드가 있을 때
		if adj[now][nxt]: 
			# 다음 노드의 dfs 호출 
			dfs(nxt)

def(0)
```

## BFS


- 큐를 사용해서 구현
- 깊이를 한단계씩 내려가면서 좌 → 우 를 훑는 방식으로 진행
- pop을 한 노드에 연결되어 있는 노드들을 큐에 Enque 해준다

- 0 → 1 → 2 → 3 → 4 → 5 → 6 → 7 → 8 → 9 → 10 → 11 → 12

큐 작동 방식

- 0 (0 pop)
- 1 2 (1 pop)
- 2 3 4 (2 pop)
- 34 56 ( 3 pop)
- 4 56 78 ( 4 pop)
- 56 78 9 (5 pop) → 5는 연결된 노드가 없음
- 6 78 9 ( 6 pop)
- 78 9 10 11 12
    
    

```python
from collections import deque

adj = [[0]*13 for _ in range(13)]
adj[0][1] = adj[0][2] = 1
adj[1][3] = adj[1][4] = 1

def bfs():
	dq = deque()
	dq.append(0)
	# 큐에 원소가 존재하는 동안 
	while dq :
		
		now = dq.popleft()
		# pop한 노드에 연결되어 있는 노드를 왼쪽부터 큐에 추가
		for nxt in range(13):
			if adj[now][nxt]:
				dq.append(nxt)

bfs()
```

## 공통점

- 그래프 탐색 알고리즘
- 완전 탐색 알고리즘
    - 장점
        - 모든 경우의 수를 다 찾아보니까 반드시 정답을 찾을 수 있다
    - 단점
        - 완전탐색은 느리다

## 차이점

![스크린샷 2022-05-19 오후 9.03.43.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cbf8d323-f9ee-4c88-88fa-a252bd58663a/스크린샷_2022-05-19_오후_9.03.43.png)

- DFS
    - 최단거리 탐색 문제에서 DFS는 모든 경우의 수를 전부 탐색해 목표 노드까지 가는 모든 경로 중 최단 거리인 경로를 찾게 된다
- BFS
    - 큐를 사용하여 구현
    - 목표 노드 까지의 최단거리를 묻는 문제
        - 루트로 부터 거리가 1인 노드들부터 차례대로 거리가 1, 2, 3, 4 인 노드들을 전부 탐색
        - 그래서 목표 최단 거리인 노드를 만나면 문제를 해결할 수 있다
            - BFS는 꼭 모든 깊이를 탐색하지 않아도 될 수 있다
        - 최단거리 문제에서는 DFS보다 유리함
    

## DFS & BFS

Vertex : 노드(V) , Edge : 간선(E)

- 인접 행렬 vs 인접리스트 의 시간 복잡도
    - 인접행렬 : $O(V^2)$
        
        ![스크린샷 2022-05-19 오후 9.07.59.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/aa1588fd-4ba2-4eaf-9c3c-750e6d3284ec/스크린샷_2022-05-19_오후_9.07.59.png)
        
    - 인접리스트 : $O(V+E) := O(max(V, E))$
        - Vertex와 Edge 중에 압도적으로 큰 숫자가 나올 경우 그 숫자가 해당되는 변수의 시간 복잡도로 취급되어도 거의 유사하다.
        - 간선 개수(E)가 적으면 인접리스트가 유리 ⇒ O(V)
        - 만약 간선 개수가 최대로 V^2 만큼 있을 경우 O(V+V^2) → O(V^2) ⇒ 인접 행렬과 유리해진다
